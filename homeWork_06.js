//homeork_06.js
// 1) Почитать про принципы программирования KISS, DRY, YAGNI + почитать про "Антипаттерны" Чистого кода

// KISS
// Аббревиатура KISS расшифровывается «keep it short and simple» — «делай кратко и просто». 
// Принцип KISS — это когда вы берёте задачу и решаете её простым способом:
// Не подключаете всю библиотеку, если нужна всего пара функций.
// Не закладываете избыточные функции, если о них не просил заказчик.
// Не используете избыточные классы и методы.
// Не перегружаете интерфейс и не делаете сложную бизнес-логику.
// Не выполняете другие действия, если они не влияют на работу проекта.
// Принцип KISS — это когда вы делаете просто и только то, что просит заказчик или работодатель.
// Принцип KISS — это когда вы пишете код, который будет понятен другим разработчикам даже через десять лет.
// Принцип KISS — это когда вы разбираетесь в задаче и чётко понимаете, когда работу можно считать выполненной.

// DRY
// Don’t repeat yourself — «не повторяйтесь».
// Про переиспользование и универсальность

// YAGNI
// You ain’t gonna need it - Тебе это не понадобится
// Cоздавать какую-то функциональность следует только тогда, когда она действительно нужна
// нужно фокусироваться только на текущей итерации проекта.

// "Антипаттерны" Чистого кода

// 1 Преждевременная оптимизация
// Сначала профилирование, потом оптимизация. Не меняйте простоту на эффективность, пока об этом не заявят эмпирически полученные данные.
// 2 Байкшеддинг
// Не тратьте много времени на простейшие решения.
// 3 Аналитический паралич
// Вместо чрезмерного анализа и спекуляций используйте пошаговое развитие
// 4 Класс Бога
// Избегайте больших классов со слишком большими ответственностями и зависимостями
// 5 Страх перед добавлением классов
// Добавление классов уменьшает сложность. Большое число классов – не признак плохого дизайна
// 6 Эффект внутренней платформы
// Избегайте переизобретения тех возможностей, которые уже есть в операционке или платформе.
// 7 Неизвестные числа и строчки
// Избегайте использования чисел или строковых констант без имён и пояснений. 
// 8 Управление через количество
// Используйте числа для информирования, а не как основу для принятия решений
// 9 Бесполезные (полтергейстные) классы
// Бесполезные классы без зависимостей, используются для вызова методов другого класса или просто добавляют ненужный слой абстракции.
// Избегайте классов без реальной ответственности.

// 2) Прочитать про способы хранения LocalStorage, SessionStorage и Cookie

// Local Storage (локальное хранилище) хранит данные бессрочно. 
// Очищается только с помощью JavaScript или очистки кэша браузера. 
// Хранит данные объёмом до 5 МБ, это самый большой объём из трёх вариантов хранилища. 
// Работает по правилу ограничения домена, то есть сохранённые данные доступны только для одного источника.

// Session Storage (сессионное хранилище) хранит данные, пока продолжается текущая сессия.
// Когда пользователь закрывает браузер, данные становятся недоступными.
// Используется контекст браузера верхнего уровня, поэтому каждая вкладка браузера хранит уникальные данные. 1

// Cookie хранит данные, которые можно передавать на сервер через заголовки.
// Срок хранения устанавливается при создании cookie. Объём данных не превышает 4 Кбайт.
// Cookie могут быть защищёнными, в этом случае их содержимое нельзя получить на стороне клиента.
// Это важно для аутентификации при хранении пользовательских токенов. 1

// 3) HTML / CSS - Базовая структура html документа, БЭМ методология

// 4) Почитать про паттерны функционального программирования + посмотреть примеры использования

// Неизменяемость данных. 
// При изменении данных создаётся новый объект, а старый остаётся неизменным.
// Это позволяет избежать ошибок, связанных с изменением данных во время выполнения программы.
const someArray = [1, 2, 3, 4]
const newArray = [...someArray, 5]
// someArray остается неизменным, а newArray содержит элементы из someArray и добавленный элемент 5.

// Чистые функции.
// Это функции, которые не имеют побочных эффектов и всегда возвращают одинаковый результат при одинаковых входных данных.
// Такие функции легко тестировать и сопровождать.
const add = (a, b) => a + b
// Функция "add" - это чистая функция, т.к. она всегда возвращает одинаковый результат для одинаковых аргументов без побочных эффектов.

// Композиция функций.
// Это процесс объединения нескольких функций в одну.
// Это позволяет создавать более сложные функции и повторно использовать код. 
// Например, можно представить бизнес-процесс как цепочку вариантов использования и скомпоновать их в функцию httpRequest -> httpResponse.
const square = x => x * x
const double = x => x * 2

const squareAndDouble = x => double(square(x))
// Функция squareAndDouble компонуется из двух простых функций, которые могут использоваться и заменять друг друга.

// Функции высшего порядка.
// Это функции, которые принимают другие функции в качестве аргументов или возвращают функции в качестве результата.
// Это позволяет создавать более абстрактный код и повышать его гибкость.
const calculate = (a, b, operation) => operation(a, b)
const sum = (a, b) => a + b
const multiply = (a, b) => a * b

const result = calculate(2, 3, sum)
const otherResult = calculate(2, 3, multiply)
// Функция calculate - это функция высшего порядка, т.к. она принимает другую функцию ("operation") в качестве аргумента.

// Рекурсия.
// Это процесс, при котором функция вызывает саму себя с терминальным условием.
// В функциональном программировании рекурсия является основным способом повторения операций.
// Она позволяет создавать более элегантный и краткий код.
const calculateFactorial = n => {
  if (n === 1) {
    return 1
  }
  return n * calculateFactorial(n - 1)
}

const resultat = calculateFactorial(5)
// Функция calculateFactorial реализована с помощью рекурсии и используется для вычисления факториала числа.

// 5) Способы позиционирования контента на странице

// Позиционирование через свойство float.
// Оно убирает элемент из обычного потока страницы и позиционирует его слева или справа от родительского элемента.
// Все остальные элементы на странице будут обтекать такой элемент.

// Позиционирование через свойство display со значением inline-block.
// Этот метод полезен для компоновки страниц или для размещения элементов в линию рядом друг с другом.
// Значение inline-block для свойства display отображает элементы в линию и позволяет им принимать все свойства блочной модели, включая height, width, padding, border и margin.

// Использование свойства position. 
// Оно определяет, как элемент позиционируется на странице и будет ли он отображаться в обычном потоке документа.
// Свойство применяется в сочетании со свойствами смещения блока — top, right, bottom и left,
// которые точно определяют, где элемент будет расположен путём перемещения элемента в разных направлениях.
// Свойство position имеет пять значений: static (статичное позиционирование), relative (относительное), absolute (абсолютное), fixed (фиксированное) и sticky (липкое).

// 6) Веса селекторов
// Специфичность — это показатель, по которому браузер определяет, какие стили применить к элементу.
// Её можно представить в виде четырёх чисел 0.0.0.0, где каждый разряд — это вес, определяемый специальными правилами.

// Наивысший приоритет — у стилей, прописанных в атрибуте style (1.0.0.0).
// На втором месте — селекторы по идентификатору (0.1.0.0).
// Затем идут три равноправные группы: селекторы по классу, атрибуту и псевдоклассы (0.0.1.0).
// На четвёртом месте — селекторы по тегу и псевдоэлементы (0.0.0.1).
// Комбинаторы ~, >, + и универсальный селектор * веса не добавляют.
// Вес псевдоклассов :is(), :has() и :not() равен весу самого специфичного селектора внутри скобок.